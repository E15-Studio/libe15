/**
 * @file autodep.c
 * @author simakeng (simakeng@outlook.com)
 * @brief generate dependencies of target
 * @version 0.1
 * @date 2023-03-07
 *
 * @copyright Copyright (c) 2023
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct dep_item
{
    unsigned int len;
    unsigned int hash;
    char *name;
};

#define HASHSZ 256
static struct dep_item *hashtab[HASHSZ];

static unsigned int strhash(const char *str, unsigned int sz)
{
    /* fnv32 hash */
    unsigned int i, hash = 2166136261U;

    for (i = 0; i < sz; i++)
        hash = (hash ^ str[i]) * 0x01000193;
    return hash;
}

static struct dep_item *hashtab_find(unsigned int hash)
{
    for (int i = 0; i < HASHSZ; i++)
    {
        if (hashtab[i] != NULL && hashtab[i]->hash == hash)
            return hashtab[i];
    }
    return NULL;
}

static void hashtab_pushback(struct dep_item *item)
{
    for (int i = 0; i < HASHSZ; i++)
    {
        if (hashtab[i] != NULL)
            continue;
        else
        {
            hashtab[i] = item;
            return;
        }
    }
}

static void hashtab_insert(char *s)
{
    unsigned int str_len = strlen(s);
    unsigned int str_hash = strhash(s, str_len);
    struct dep_item *item = (struct dep_item *)malloc(sizeof(struct dep_item));

    item->hash = str_hash;
    item->len = str_len;
    item->name = s;
    struct dep_item *prev_item = hashtab_find(str_hash);
    if (prev_item == NULL)
    {
        hashtab_pushback(item);
        return;
    }
    else
    {
        free(prev_item->name);
        prev_item->name = s;
        free(item);
        return;
    }
}

static void error_exit(int code, const char *prompt)
{
    fprintf(stderr, "autodep exited with code %d: ", code);
    fprintf(stderr, "%s\n", prompt);
    exit(code);
}

static void usage(void)
{
    fprintf(stderr, "Usage: autodep <depfile> <target> <cmdline>\n");
    fprintf(stderr, "depfile : dependencies generated by gcc -MD\n");
    fprintf(stderr, "target  : genenrated target file\n");
    fprintf(stderr, "cmdline : command line args to genenrate target\n");

    error_exit(-1, "invalid command line arguments.\n");
}

static int is_blank(char c)
{
    return c == ' ' || c == '\n' || c == '\\';
}

/**
 * @brief interpret pointer from current char to next blank as a item
 *
 * @param str
 * @return char*
 */
static char *get_item_end(char *str)
{
    char *start = str;
    while (!is_blank(*str) && *str != 0)
        str++;
    return str;
}

static char *get_sub_str(char *begin, char *end)
{
    int item_str_len = end - begin;
    char *item_str = (char *)malloc(item_str_len + 1);
    memcpy(item_str, begin, item_str_len);
    item_str[item_str_len] = 0;
    return item_str;
}
/**
 * @brief This function will parse all dependencies and store into hash maps;
 *
 * @param text
 * @param target
 */
static void parse_dependencies(char *text, const char *target)
{
    char *m = strstr(text, ":");

    if (m == NULL)
        error_exit(-4, "not a valid .d file!");

    while (*(++m) != 0)
    {
        // skip blanks
        if (is_blank(*m))
            continue;

        char *item_end = get_item_end(m);

        char *item_str = get_sub_str(m, item_end);

        m = item_end;

        hashtab_insert(item_str);
    }
}

static char *load_depfile(const char *filename)
{
    FILE *fp = fopen(filename, "r");
    size_t fsize;
    char *fbuf;
    if (fp == NULL)
        error_exit(-2, "can't open dep file\n");
    fseek(fp, 0, SEEK_END);
    fsize = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    fbuf = (char *)malloc(fsize + 1);
    fread(fbuf, 1, fsize, fp);
    fbuf[fsize] = 0;

    fclose(fp);

    return fbuf;
}

int main(int argc, char *argv[])
{
    const char *depfile, *target, *cmdline;
    char *depfile_content = NULL;

    if (argc != 4)
        usage();

    depfile = argv[1];
    target = argv[2];
    cmdline = argv[3];

    

    depfile_content = load_depfile(depfile);
    parse_dependencies(depfile_content, target);

    printf("%s : \\\n", target);
    for (int i = 0; i < HASHSZ; i++)
    {
        if (hashtab[i] != NULL)
        {
            printf("    %s \\ \n", hashtab[i]->name);
        }
    }

    return 0;
}